import json
import os.path
import ssl
import tempfile
from base64 import b64decode

from copy import deepcopy

import aiohttp
import pytest
from aiohttp import web, ClientResponseError
from aiohttp.test_utils import TestServer as Server
from krake.data.config import TlsClientConfiguration, TlsServerConfiguration

from krake import utils
from krake.api.app import create_app
from krake.controller import create_ssl_context
from krake.data.core import resource_ref
from krake.data.kubernetes import (
    Application,
    ApplicationState,
    ApplicationComplete,
    ApplicationShutdown
)
from krake.controller.kubernetes.application import KubernetesApplicationController
from krake.client import Client
from krake.test_utils import server_endpoint, get_first_container

from tests.factories.kubernetes import (
    ApplicationFactory,
    ClusterFactory,
    make_kubeconfig,
)
from yarl import URL

from tests.controller.kubernetes import (
    deployment_manifest,
    custom_deployment_observer_schema,
    deployment_response,
    secret_response,
)


async def test_complete_hook(aiohttp_server, config, db, loop, hooks_config):
    """Verify that the Controller mangled the received Application to add elements of
    the "complete" hook if it had been enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: only check the content of k8s resources generated by the "complete" hook.

    Expectations:
        Environment variables are added to the Deployment in the manifest file of the
        deployed Application.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the deployment. We
    # augment the standard API Response with the additional "env" dictionary that
    # contains the TOKEN and the URL taken from secret
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        # Create the controller and configure the hooks
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)

        # The application is received by the Controller, which starts the reconciliation
        # loop, creates the application and updates the DB accordingly
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    # Mangled `env` dictionary should be observed
    for observer_schema in stored.status.mangled_observer_schema:
        if observer_schema["kind"] == "Deployment":
            for container in observer_schema["spec"]["template"]["spec"]["containers"][
                :-1
            ]:
                assert container["env"] == [
                    {
                        "name": None,
                        "valueFrom": {"secretKeyRef": {"key": None, "name": None}},
                    },
                    {
                        "name": None,
                        "valueFrom": {"secretKeyRef": {"key": None, "name": None}},
                    },
                    {
                        "observer_schema_list_min_length": 2,
                        "observer_schema_list_max_length": 2,
                    },
                ]
        if observer_schema["kind"] == "Secret":
            assert (
                observer_schema["metadata"]["name"]
                == secret_mangled_response["metadata"]["name"]
            )
            assert (
                observer_schema["data"].keys() == secret_mangled_response["data"].keys()
            )

    # Mangled `env` dictionary should be present in last_applied_manifest and
    # last_observed_manifest
    for resource in stored.status.last_applied_manifest:
        if resource["kind"] == "Deployment":
            for container in resource["spec"]["template"]["spec"]["containers"]:
                assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"]]
                assert "KRAKE_COMPLETE_URL" in [env["name"] for env in container["env"]]

        if resource["kind"] == "Secret":
            assert (
                resource["metadata"]["name"]
                == secret_mangled_response["metadata"]["name"]
            )
            assert resource["data"] == secret_mangled_response["data"]

    for resource in stored.status.last_observed_manifest:
        if resource["kind"] == "Deployment":
            # Loop over observed containers, but exclude special control list
            for container in resource["spec"]["template"]["spec"]["containers"][:-1]:
                assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"][:-1]]
                assert "KRAKE_COMPLETE_URL" in [
                    env["name"] for env in container["env"][:-1]
                ]

                # Check special control dictionary
                assert len(container["env"]) == 3
                assert container["env"][-1] == {
                    "observer_schema_list_current_length": 2
                }

        if resource["kind"] == "Secret":
            assert (
                resource["metadata"]["name"]
                == secret_mangled_response["metadata"]["name"]
            )
            assert resource["data"] == secret_mangled_response["data"]

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_complete_hook_disable_by_user(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller did not mangle the received Application to add
    elements of the "complete" hook if it had not been enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: complete hook not set by the user

    Expectations:
        No resource is added in the app's manifest.

    """
    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        # As a response, the k8s API provides the full Deployment object
        return web.json_response(deployment_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should not be modified by the "complete" hook with ENV vars.
    #
    # When received by the k8s controller, the application is in PENDING state and
    # scheduled to a cluster. It contains a manifest and a custom observer_schema.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        # Create the controller and configure the hooks
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)

        # The resource is received by the controller, which starts the reconciliation
        # loop, and updates the application in the DB accordingly.
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    # Complete hook is disabled, so no additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 1
    for resource in stored.status.last_observed_manifest:
        assert resource["kind"] == "Deployment"
        for container in resource["spec"]["template"]["spec"]["containers"]:
            assert "env" not in container

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_complete_hook_tls(
    aiohttp_server, config, pki, db, loop, client_ssl_context, hooks_config
):
    """Verify that the Controller mangled the received Application to add elements of
    the "complete" hook if it had been enabled when the communication with TLS was
    enabled.

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: only check the content of k8s resources generated by the "complete" hook.

    Expectations:
        A ConfigMap is added in the manifest file, as well as its mounting point in the
        Deployment of the ConfigMap.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    ssl_context = client_ssl_context("client")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = app["spec"][
            "template"
        ]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)

        # The resource is received by the controller, which starts the reconciliation
        # loop, mangles the manifest file, creates the Deployment and the ConfigMap, and
        # updates the DB accordingly
        await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # The last_applied_manifest, last_observed_manifest, and observer_schema, should
    # contain the Deployment and two Secrets
    # (Environment variables secret and TLS secret)
    assert len(stored.status.mangled_observer_schema) == 3
    assert len(stored.status.last_applied_manifest) == 3
    assert len(stored.status.last_observed_manifest) == 3

    containers = stored.status.mangled_observer_schema[0]["spec"]["template"]["spec"][
        "containers"
    ]

    # The `env` and `volumeMounts` sub-resources should be observed
    assert stored.status.mangled_observer_schema[0]["kind"] == "Deployment"
    for container in containers[:-1]:
        assert "volumeMounts" in container
        assert container["env"] == [
            {"name": None, "valueFrom": {"secretKeyRef": {"key": None, "name": None}}},
            {"name": None, "valueFrom": {"secretKeyRef": {"key": None, "name": None}}},
            {
                "observer_schema_list_min_length": 2,
                "observer_schema_list_max_length": 2,
            },
        ]

    containers = stored.status.last_applied_manifest[0]["spec"]["template"]["spec"][
        "containers"
    ]
    # The last_applied_manifest and last_observed_manifest should contain the mangled
    # sub-resources `volumeMounts` and `env`
    assert stored.status.last_applied_manifest[0]["kind"] == "Deployment"
    for container in containers:
        assert "volumeMounts" in container
        assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"]]
        assert "KRAKE_COMPLETE_URL" in [env["name"] for env in container["env"]]

    assert stored.status.last_observed_manifest[0]["kind"] == "Deployment"
    assert (
        stored.status.last_observed_manifest[0]["metadata"]["namespace"] == "secondary"
    )
    for container in stored.status.last_observed_manifest[0]["spec"]["template"][
        "spec"
    ]["containers"][:-1]:
        assert "volumeMounts" in container
        assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"][:-1]]
        assert "KRAKE_COMPLETE_URL" in [env["name"] for env in container["env"][:-1]]
        assert len(container["env"]) == 3
        assert container["env"][-1] == {"observer_schema_list_current_length": 2}

    # The last_applied_manifest and last_observed_manifest should contain the mangled
    # resource Secrets
    assert stored.status.last_applied_manifest[1]["kind"] == "Secret"
    assert stored.status.last_applied_manifest[2]["kind"] == "Secret"
    assert (
        stored.status.last_observed_manifest[0]["metadata"]["namespace"] == "secondary"
    )

    for index, secret_resp in enumerate(secret_mangled_responses):
        assert (
            stored.status.last_applied_manifest[index + 1]["kind"]
            == secret_resp["kind"]
        )
        assert (
            stored.status.last_applied_manifest[index + 1]["metadata"]["name"]
            == secret_resp["metadata"]["name"]
        )
        assert (
            stored.status.last_applied_manifest[index + 1]["data"]
            == secret_resp["data"]
        )

    # There are no list in the Secret resource, therefore there are no special
    # control dictionary added. In this specific case, it is equal to the Secret
    # resource
    assert stored.status.last_observed_manifest[1]["kind"] == "Secret"
    assert stored.status.last_observed_manifest[2]["kind"] == "Secret"

    # The mangled resource Secret should be observed
    assert stored.status.mangled_observer_schema[1]["kind"] == "Secret"
    assert stored.status.mangled_observer_schema[2]["kind"] == "Secret"
    for index, secret_resp in enumerate(secret_mangled_responses):
        assert (
            stored.status.mangled_observer_schema[index + 1]["kind"]
            == secret_resp["kind"]
        )
        assert (
            stored.status.mangled_observer_schema[index + 1]["metadata"]["name"]
            == secret_resp["metadata"]["name"]
        )

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_complete_hook_default_namespace(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller mangled the received Application to add elements of
    the "complete" hook if it had been enabled, even if the resources have been created
    without any namespace.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: no Kubernetes namespace is specified in the manifest file provided to
       create the Application. Check the content of k8s resources generated by the
       "complete" hook.

    Expectations:
        The Kubernetes resources are created, and they do not have any namespace added
        to them.

    """
    deployment_created = False
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/default/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/default/deployments")
    async def _(request):
        nonlocal deployment_created, deploy_mangled_response
        deployment_created = True

        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/default/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    copy_deployment_manifest = deepcopy(deployment_manifest)
    # Create a manifest with resources without any namespace.
    del copy_deployment_manifest["metadata"]["namespace"]

    # When received by the k8s controller, the application is in PENDING state and
    # scheduled to a cluster. It contains a manifest and a custom observer_schema.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[copy_deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    assert deployment_created

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    for resource in stored.status.last_applied_manifest:
        if resource["kind"] == "Deployment":
            for container in resource["spec"]["template"]["spec"]["containers"]:
                assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"]]
                assert "KRAKE_COMPLETE_URL" in [env["name"] for env in container["env"]]

        if resource["kind"] == "Secret":
            assert (
                resource["metadata"]["name"]
                == secret_mangled_response["metadata"]["name"]
            )
            assert resource["data"] == secret_mangled_response["data"]

    for resource in stored.status.last_observed_manifest:
        if resource["kind"] == "Deployment":
            # Loop over observed containers, but exclude special control list
            for container in resource["spec"]["template"]["spec"]["containers"][:-1]:
                assert "KRAKE_COMPLETE_TOKEN" in [env["name"] for env in container["env"][:-1]]
                assert "KRAKE_COMPLETE_URL" in [
                    env["name"] for env in container["env"][:-1]
                ]

                # Check special control dictionary
                assert len(container["env"]) == 3
                assert container["env"][-1] == {
                    "observer_schema_list_current_length": 2
                }

        if resource["kind"] == "Secret":
            assert (
                resource["metadata"]["name"]
                == secret_mangled_response["metadata"]["name"]
            )
            assert resource["data"] == secret_mangled_response["data"]

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


def get_complete_hook_environment_value(application):
    """From an Application that has been mangled with the "complete" hook, get the value
    of the token and the URL that were added to it.

    Args:
        application (Application): the Application augmented with the elements of the
            "complete" hook.

    Returns:
        (str, str): a tuple of two elements: the token generated by the "complete" hook
            and the URL of the Krake API, as inserted by the hook.


    """
    deployment = application.status.last_observed_manifest[0]
    secret = {}
    for manifest in application.status.last_observed_manifest:
        if manifest["kind"] == "Secret" and manifest["metadata"]["name"].endswith(
            "krake-complete-secret-token"
        ):
            secret = manifest

    token = None
    url = None
    token_key = None
    url_key = None
    for container in deployment["spec"]["template"]["spec"]["containers"][:-1]:
        for env in container["env"][:-1]:
            if env["name"] == "KRAKE_COMPLETE_TOKEN":
                token_key = env["valueFrom"]["secretKeyRef"]["key"]
            if env["name"] == "KRAKE_COMPLETE_URL":
                url_key = env["valueFrom"]["secretKeyRef"]["key"]

    token = b64decode(secret["data"][token_key]).decode()
    url = b64decode(secret["data"][url_key]).decode()

    if token is None or url is None:
        raise ValueError("The token and the url must be in the environment")

    return token, url


async def test_complete_hook_external_endpoint(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller set the URL for the Krake endpoint based on the
    external endpoint set in the "complete" hook configuration.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: set the external endpoint in the "complete" hook configuration, with
       "https" as scheme, even though TLS is disabled.

    Expectations:
        The URL in the KRAKE_URL environment variable has the external endpoint set as
        host, and that the scheme was changed to "http".

    """
    hooks_config.complete.external_endpoint = "https://new.external.endpoint"
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response

        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    _, url = get_complete_hook_environment_value(stored)
    endpoint = URL(url)
    assert endpoint.host == "new.external.endpoint"
    assert endpoint.scheme == "http"


async def test_complete_hook_sending(aiohttp_server, config, db, loop, hooks_config):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, without TLS enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: send a request to the "complete" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources are enough to use
        the "complete" hook endpoint, and the request sent to this endpoint led to the
        deletion of the Application on the API.

    """
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the deployment. We
    # augment the standard API Response with the additional "env" dictionary that
    # contains the TOKEN and the URL
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    token, url = get_complete_hook_environment_value(stored)

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        complete = ApplicationComplete(token=token)
        resp = await client.session.put(url, json=complete.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None


async def test_complete_hook_sending_tls(
    aiohttp_server, config, pki, db, loop, client_ssl_context, hooks_config
):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, with TLS enabled.

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: send a request to the "complete" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources and
        Kubernetes Secret are enough to use the "complete" hook endpoint,
        and the request sent to this endpoint led to the deletion of the
        Application on the API.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    ssl_context = client_ssl_context("client")

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = app["spec"][
            "template"
        ]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)
        await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is None

    token, url = get_complete_hook_environment_value(stored)

    # Attempt to send a request to the hook endpoint without a certificate. Should fail.
    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        complete = ApplicationComplete(token=token)
        # `ClientSSLError` encompasses both `ClientConnectorCertificateError` and
        # `ClientConnectorSSLError`. With Python 3.6, a `ClientConnectorSSLError` is
        # raised, while with 3.7 an update of the ssl module makes aiohttp raise a
        # `ClientConnectorCertificateError`.
        with pytest.raises(aiohttp.ClientSSLError):
            await client.session.put(url, json=complete.serialize())

    # Attempt to send a request to the hook endpoint with the cert taken from the
    # deployed Application. Should succeed.
    secret_certs = stored.status.last_observed_manifest[1]
    # Load the certificates into an SSL context.
    with tempfile.TemporaryDirectory() as tmpdirname:
        cert_paths = {}
        # Write the CA, the certificate and the key to files.
        for file_name, content in secret_certs["data"].items():
            cert_path = os.path.join(tmpdirname, file_name)
            cert_paths[file_name] = cert_path
            content_decoded = b64decode(content).decode()

            with open(cert_path, "w") as f:
                f.write(content_decoded)

        hook_ssl_context = ssl.create_default_context(
            cafile=cert_paths["ca-bundle.pem"]
        )
        hook_ssl_context.load_cert_chain(
            certfile=cert_paths["cert.pem"], keyfile=cert_paths["key.pem"]
        )

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=hook_ssl_context
    ) as client:
        complete = ApplicationComplete(token=token)
        resp = await client.session.put(url, json=complete.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None


async def test_complete_hook_sending_tls_rbac(
    aiohttp_server, config, pki, db, loop, rbac_allow, client_ssl_context, hooks_config
):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, with TLS enabled and RBAC set on the API.

    Conditions:
     * TLS:  enabled
     * RBAC: enabled
     * extras: send a request to the "complete" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources are enough to use
        the "complete" hook endpoint, and the request sent to this endpoint led to the
        deletion of the Application on the API.

    """
    config.authorization = "RBAC"
    config.authentication.strategy.static.enabled = False

    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []
    routes = web.RouteTableDef()

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    client_user = "client"
    controller_ssl_context = client_ssl_context(client_user)
    invalid_ssl_context = client_ssl_context("invalid_user")

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = app["spec"][
            "template"
        ]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=controller_ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=controller_ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)

        # As RBAC is set, the user defined in the Controller's certificate has to be
        # allowed to perform specific actions.
        async with rbac_allow(
            "kubernetes", "applications", "update", override_user=client_user
        ):
            async with rbac_allow(
                "kubernetes", "applications/status", "update", override_user=client_user
            ):
                async with rbac_allow(
                    "kubernetes", "clusters", "get", override_user=client_user
                ):
                    await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is None

    token, url = get_complete_hook_environment_value(stored)

    # Attempt to send a request to the hook endpoint with a valid certificate but a
    # non-allowed user. Should fail because of RBAC -> return a "403 Forbidden".
    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=invalid_ssl_context
    ) as client:
        complete = ApplicationComplete(token=token)
        with pytest.raises(ClientResponseError, match="403"):
            await client.session.put(url, json=complete.serialize())

    # Attempt to send a request to the hook endpoint with a valid certificate, taken
    # from the Application itself. Should succeed.
    configmap = stored.status.last_observed_manifest[1]

    # Load the certificates into an SSL context.
    with tempfile.TemporaryDirectory() as tmpdirname:
        cert_paths = {}
        # Write the CA, the certificate and the key to files.
        for file_name, content in configmap["data"].items():
            cert_path = os.path.join(tmpdirname, file_name)
            cert_paths[file_name] = cert_path
            content_decoded = b64decode(content).decode()

            with open(cert_path, "w") as f:
                f.write(content_decoded)

        hook_ssl_context = ssl.create_default_context(
            cafile=cert_paths["ca-bundle.pem"]
        )
        hook_ssl_context.load_cert_chain(
            certfile=cert_paths["cert.pem"], keyfile=cert_paths["key.pem"]
        )

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=hook_ssl_context
    ) as client:
        complete = ApplicationComplete(token=token)

        # Allow the user defined in hooks-token.
        async with rbac_allow(
            "kubernetes",
            "applications/complete",
            "update",
            override_user="test-complete-hook-user",
        ):
            resp = await client.session.put(url, json=complete.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None


async def test_complete_hook_reschedule(
    aiohttp_server, config, pki, db, loop, hooks_config
):
    """Attempt to reschedule an Application augmented with the "complete" hook. Enable
    TLS to use the "full-featured" hook (with the Secret containing a certificate).

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: give the Application a second time to the Kubernetes controller, to
       trigger it to handle the Application as if it was rescheduled. Have TLS enabled
       to generate a ConfigMap on the Application.

    Expectations:
        The rescheduling should occur without any interference of the resources
        generated by the "complete" hook and without any change applied to these
        resources.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    client_cert = pki.gencert("client")
    client_tls = TlsClientConfiguration(
        enabled=True,
        client_ca=pki.ca.cert,
        client_cert=client_cert.cert,
        client_key=client_cert.key,
    )
    ssl_context = create_ssl_context(client_tls)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = app["spec"][
            "template"
        ]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["complete"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)
        # Observer started here in order to be stopped afterwards,
        # otherwise get an exception from the Controller trying to stop a non-existing
        # Observer.
        await controller.resource_received(app, start_observer=True)

        stored = await db.get(
            Application, namespace=app.metadata.namespace, name=app.metadata.name
        )
        assert stored.status.state == ApplicationState.RUNNING
        assert stored.status.last_observed_manifest is not None

        # Do a rescheduling --> start the reconciliation loop
        await controller.resource_received(stored, start_observer=False)

        stored = await db.get(
            Application, namespace=app.metadata.namespace, name=app.metadata.name
        )
        assert stored.status.state == ApplicationState.RUNNING
        assert stored.status.last_observed_manifest is not None


async def test_shutdown_hook(aiohttp_server, config, db, loop, hooks_config):
    """Verify that the Controller mangled the received Application to add elements of
    the "shutdown" hook if it had been enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: only check the content of k8s resources generated by the "shutdown" hook.

    Expectations:
        Environment variables are added to the Deployment in the manifest file of the
        deployed Application.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the deployment. We
    # augment the standard API Response with the additional "env" dictionary that
    # contains the TOKEN and the URL taken from secret
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        # Create the controller and configure the hooks
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)

        # The application is received by the Controller, which starts the reconciliation
        # loop, creates the application and updates the DB accordingly
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    # Mangled `env` dictionary should be observed
    for observer_schema in stored.status.mangled_observer_schema:
        if observer_schema["kind"] == "Deployment":
            for container in observer_schema["spec"]["template"]["spec"]["containers"][:-1]:
                assert container["env"] == [
                    {
                        "name": None,
                        "valueFrom": {"secretKeyRef": {"key": None, "name": None}},
                    },
                    {
                        "name": None,
                        "valueFrom": {"secretKeyRef": {"key": None, "name": None}},
                    },
                    {
                        "observer_schema_list_min_length": 2,
                        "observer_schema_list_max_length": 2,
                    },
                ]
        if observer_schema["kind"] == "Secret":
            assert observer_schema["metadata"]["name"] == secret_mangled_response["metadata"]["name"]
            assert observer_schema["data"].keys() == secret_mangled_response["data"].keys()

    # Mangled `env` dictionary should be present in last_applied_manifest and
    # last_observed_manifest
    for resource in stored.status.last_applied_manifest:
        if resource["kind"] == "Deployment":
            for container in resource["spec"]["template"]["spec"]["containers"]:
                assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"]]
                assert "KRAKE_SHUTDOWN_URL" in [env["name"] for env in container["env"]]

        if resource["kind"] == "Secret":
            assert resource["metadata"]["name"] == secret_mangled_response["metadata"]["name"]
            assert resource["data"] == secret_mangled_response["data"]

    for resource in stored.status.last_observed_manifest:
        if resource["kind"] == "Deployment":
            # Loop over observed containers, but exclude special control list
            for container in resource["spec"]["template"]["spec"]["containers"][:-1]:
                assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"][:-1]]
                assert "KRAKE_SHUTDOWN_URL" in [
                    env["name"] for env in container["env"][:-1]
                ]

                # Check special control dictionary
                assert len(container["env"]) == 3
                assert container["env"][-1] == {"observer_schema_list_current_length": 2}

        if resource["kind"] == "Secret":
            assert resource["metadata"]["name"] == secret_mangled_response["metadata"]["name"]
            assert resource["data"] == secret_mangled_response["data"]

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_shutdown_hook_disable_by_user(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller did not mangle the received Application to add
    elements of the "shutdown" hook if it had not been enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: complete hook not set by the user

    Expectations:
        No resource is added in the app's manifest.

    """
    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        # As a response, the k8s API provides the full Deployment object
        return web.json_response(deployment_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should not be modified by the "complete" hook with ENV vars.
    #
    # When received by the k8s controller, the application is in PENDING state and
    # scheduled to a cluster. It contains a manifest and a custom observer_schema.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        # Create the controller and configure the hooks
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)

        # The resource is received by the controller, which starts the reconciliation
        # loop, and updates the application in the DB accordingly.
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    # Complete hook is disabled, so no additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 1
    for resource in stored.status.last_observed_manifest:
        assert resource["kind"] == "Deployment"
        for container in resource["spec"]["template"]["spec"]["containers"]:
            assert "env" not in container

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_shutdown_hook_tls(
    aiohttp_server, config, pki, db, loop, client_ssl_context, hooks_config
):
    """Verify that the Controller mangled the received Application to add elements of
    the "shutdown" hook if it had been enabled when the communication with TLS was
    enabled.

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: only check the content of k8s resources generated by the "shutdown" hook.

    Expectations:
        A ConfigMap is added in the manifest file, as well as its mounting point in the
        Deployment of the ConfigMap.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    ssl_context = client_ssl_context("client")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = \
            app["spec"]["template"]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)

        # The resource is received by the controller, which starts the reconciliation
        # loop, mangles the manifest file, creates the Deployment and the ConfigMap, and
        # updates the DB accordingly
        await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # The last_applied_manifest, last_observed_manifest, and observer_schema, should
    # contain the Deployment and two Secrets
    # (Environment variables secret and TLS secret)
    assert len(stored.status.mangled_observer_schema) == 3
    assert len(stored.status.last_applied_manifest) == 3
    assert len(stored.status.last_observed_manifest) == 3

    containers = stored.status.mangled_observer_schema[0]["spec"]["template"]["spec"][
        "containers"
    ]

    # The `env` and `volumeMounts` sub-resources should be observed
    assert stored.status.mangled_observer_schema[0]["kind"] == "Deployment"
    for container in containers[:-1]:
        assert "volumeMounts" in container
        assert container["env"] == [
            {"name": None, "valueFrom": {"secretKeyRef": {"key": None, "name": None}}},
            {"name": None, "valueFrom": {"secretKeyRef": {"key": None, "name": None}}},
            {
                "observer_schema_list_min_length": 2,
                "observer_schema_list_max_length": 2,
            },
        ]

    containers = stored.status.last_applied_manifest[0]["spec"]["template"]["spec"][
        "containers"
    ]
    # The last_applied_manifest and last_observed_manifest should contain the mangled
    # sub-resources `volumeMounts` and `env`
    assert stored.status.last_applied_manifest[0]["kind"] == "Deployment"
    for container in containers:
        assert "volumeMounts" in container
        assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"]]
        assert "KRAKE_SHUTDOWN_URL" in [env["name"] for env in container["env"]]

    assert stored.status.last_observed_manifest[0]["kind"] == "Deployment"
    assert (
        stored.status.last_observed_manifest[0]["metadata"]["namespace"] == "secondary"
    )
    for container in stored.status.last_observed_manifest[0]["spec"]["template"][
        "spec"
    ]["containers"][:-1]:
        assert "volumeMounts" in container
        assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"][:-1]]
        assert "KRAKE_SHUTDOWN_URL" in [env["name"] for env in container["env"][:-1]]
        assert len(container["env"]) == 3
        assert container["env"][-1] == {"observer_schema_list_current_length": 2}

    # The last_applied_manifest and last_observed_manifest should contain the mangled
    # resource Secrets
    assert stored.status.last_applied_manifest[1]["kind"] == "Secret"
    assert stored.status.last_applied_manifest[2]["kind"] == "Secret"
    assert (
        stored.status.last_observed_manifest[0]["metadata"]["namespace"] == "secondary"
    )

    for index, secret_resp in enumerate(secret_mangled_responses):
        assert (
            stored.status.last_applied_manifest[index + 1]["kind"]
            == secret_resp["kind"]
        )
        assert (
            stored.status.last_applied_manifest[index + 1]["metadata"]["name"]
            == secret_resp["metadata"]["name"]
        )
        assert (
            stored.status.last_applied_manifest[index + 1]["data"]
            == secret_resp["data"]
        )

    # There are no list in the Secret resource, therefore there are no special
    # control dictionary added. In this specific case, it is equal to the Secret
    # resource
    assert stored.status.last_observed_manifest[1]["kind"] == "Secret"
    assert stored.status.last_observed_manifest[2]["kind"] == "Secret"

    # The mangled resource Secret should be observed
    assert stored.status.mangled_observer_schema[1]["kind"] == "Secret"
    assert stored.status.mangled_observer_schema[2]["kind"] == "Secret"
    for index, secret_resp in enumerate(secret_mangled_responses):
        assert (
            stored.status.mangled_observer_schema[index + 1]["kind"]
            == secret_resp["kind"]
        )
        assert (
            stored.status.mangled_observer_schema[index + 1]["metadata"]["name"]
            == secret_resp["metadata"]["name"]
        )

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


async def test_shutdown_hook_default_namespace(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller mangled the received Application to add elements of
    the "shutdown" hook if it had been enabled, even if the resources have been created
    without any namespace.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: no Kubernetes namespace is specified in the manifest file provided to
       create the Application. Check the content of k8s resources generated by the
       "shutdown" hook.

    Expectations:
        The Kubernetes resources are created, and they do not have any namespace added
        to them.

    """
    deployment_created = False
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/default/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/default/deployments")
    async def _(request):
        nonlocal deployment_created, deploy_mangled_response
        deployment_created = True

        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/default/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    copy_deployment_manifest = deepcopy(deployment_manifest)
    # Create a manifest with resources without any namespace.
    del copy_deployment_manifest["metadata"]["namespace"]

    # When received by the k8s controller, the application is in PENDING state and
    # scheduled to a cluster. It contains a manifest and a custom observer_schema.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["shutdown"],
        spec__manifest=[copy_deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    assert deployment_created

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    for resource in stored.status.last_applied_manifest:
        if resource["kind"] == "Deployment":
            for container in resource["spec"]["template"]["spec"]["containers"]:
                assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"]]
                assert "KRAKE_SHUTDOWN_URL" in [env["name"] for env in container["env"]]

        if resource["kind"] == "Secret":
            assert resource["metadata"]["name"] == secret_mangled_response["metadata"]["name"]
            assert resource["data"] == secret_mangled_response["data"]

    for resource in stored.status.last_observed_manifest:
        if resource["kind"] == "Deployment":
            # Loop over observed containers, but exclude special control list
            for container in resource["spec"]["template"]["spec"]["containers"][:-1]:
                assert "KRAKE_SHUTDOWN_TOKEN" in [env["name"] for env in container["env"][:-1]]
                assert "KRAKE_SHUTDOWN_URL" in [
                    env["name"] for env in container["env"][:-1]
                ]

                # Check special control dictionary
                assert len(container["env"]) == 3
                assert container["env"][-1] == {"observer_schema_list_current_length": 2}

        if resource["kind"] == "Secret":
            assert resource["metadata"]["name"] == secret_mangled_response["metadata"]["name"]
            assert resource["data"] == secret_mangled_response["data"]

    assert stored.status.state == ApplicationState.RUNNING
    assert stored.metadata.finalizers[-1] == "kubernetes_resources_deletion"


def get_shutdown_hook_environment_value(application):
    """From an Application that has been mangled with the "shutdown" hook, get the value
    of the token and the URL that were added to it.

    Args:
        application (Application): the Application augmented with the elements of the
            "shutdown" hook.

    Returns:
        (str, str): a tuple of two elements: the token generated by the "shutdown" hook
            and the URL of the Krake API, as inserted by the hook.


    """
    deployment = application.status.last_observed_manifest[0]
    secret = {}
    for manifest in application.status.last_observed_manifest:
        if manifest["kind"] == "Secret" and manifest["metadata"]["name"].endswith(
            "krake-shutdown-secret-token"
        ):
            secret = manifest

    token = None
    url = None
    token_key = None
    url_key = None
    for container in deployment["spec"]["template"]["spec"]["containers"][:-1]:
        for env in container["env"][:-1]:
            if env["name"] == "KRAKE_SHUTDOWN_TOKEN":
                token_key = env["valueFrom"]["secretKeyRef"]["key"]
            if env["name"] == "KRAKE_SHUTDOWN_URL":
                url_key = env["valueFrom"]["secretKeyRef"]["key"]

    token = b64decode(secret["data"][token_key]).decode()
    url = b64decode(secret["data"][url_key]).decode()

    if token is None or url is None:
        raise ValueError("The token and the url must be in the environment")

    return token, url


async def test_shutdown_hook_external_endpoint(
    aiohttp_server, config, db, loop, hooks_config
):
    """Verify that the Controller set the URL for the Krake endpoint based on the
    external endpoint set in the "shutdown" hook configuration.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: set the external endpoint in the "shutdown" hook configuration, with
       "https" as scheme, even though TLS is disabled.

    Expectations:
        The URL in the KRAKE_URL environment variable has the external endpoint set as
        host, and that the scheme was changed to "http".

    """
    hooks_config.shutdown.external_endpoint = "http://new.external.endpoint"
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        # No `nginx-demo` Deployment exist
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response

        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    # TLS is disabled, so only one (Kubernetes secret which stores Krake
    # authentication token and the Krake complete hook URL)
    # additional resource has been generated
    assert len(stored.status.last_observed_manifest) == 2

    _, url = get_shutdown_hook_environment_value(stored)
    endpoint = URL(url)
    assert endpoint.host == "new.external.endpoint"
    assert endpoint.scheme == "http"


async def test_shutdown_hook_sending(aiohttp_server, config, db, loop, hooks_config):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, without TLS enabled.

    Conditions:
     * TLS:  disabled
     * RBAC: disabled
     * extras: send a request to the "shutdown" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources are enough to use
        the "shutdown" hook endpoint, and the request sent to this endpoint led to the
        deletion of the Application on the API.

    """
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)

    routes = web.RouteTableDef()

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates the deployment. We
    # augment the standard API Response with the additional "env" dictionary that
    # contains the TOKEN and the URL
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]

        return web.json_response(deploy_mangled_response)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application.
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        rd = await request.read()
        secret = json.loads(rd)

        secret_mangled_response["metadata"]["name"] = secret["metadata"]["name"]
        secret_mangled_response["data"] = secret["data"]
        return web.json_response(secret_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.WAITING_FOR_CLEANING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        status__shutdown_grace_period=utils.now(),
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    api_server = await aiohttp_server(create_app(config))

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server), worker_count=0, hooks=hooks_config
        )
        await controller.prepare(client)
        await controller.resource_received(app)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )

    token, url = get_shutdown_hook_environment_value(stored)

    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        resp = await client.session.delete(url[:-9])
        assert resp.status == 200

        app_status = Application(metadata=stored.metadata,
                                 spec=stored.spec,
                                 status=stored.status)
        app_status.status.state = ApplicationState.WAITING_FOR_CLEANING
        resp = await client.session.put(url[:-8] + "status", json=app_status.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None
    assert stored.status.shutdown_grace_period is not None

    async with Client(url=server_endpoint(api_server), loop=loop) as client:

        shutdown = ApplicationShutdown(token=token)
        resp = await client.session.put(url, json=shutdown.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.status.shutdown_grace_period is None


async def test_shutdown_hook_sending_tls(
    aiohttp_server, config, pki, db, loop, client_ssl_context, hooks_config
):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, with TLS enabled.

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: send a request to the "complete" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources and
        Kubernetes Secret are enough to use the "complete" hook endpoint,
        and the request sent to this endpoint led to the deletion of the
        Application on the API.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    ssl_context = client_ssl_context("client")

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = app["spec"][
            "template"
        ]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        status__shutdown_grace_period=utils.now(),
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)
        await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is None

    token, url = get_shutdown_hook_environment_value(stored)

    # Attempt to send a request to the hook endpoint without a certificate. Should fail.
    async with Client(url=server_endpoint(api_server), loop=loop) as client:
        shutdown = ApplicationShutdown(token=token)
        # `ClientSSLError` encompasses both `ClientConnectorCertificateError` and
        # `ClientConnectorSSLError`. With Python 3.6, a `ClientConnectorSSLError` is
        # raised, while with 3.7 an update of the ssl module makes aiohttp raise a
        # `ClientConnectorCertificateError`.
        with pytest.raises(aiohttp.ClientSSLError):
            await client.session.put(url, json=shutdown.serialize())

    # Attempt to send a request to the hook endpoint with the cert taken from the
    # deployed Application. Should succeed.
    secret_certs = stored.status.last_observed_manifest[1]
    # Load the certificates into an SSL context.
    with tempfile.TemporaryDirectory() as tmpdirname:
        cert_paths = {}
        # Write the CA, the certificate and the key to files.
        for file_name, content in secret_certs["data"].items():
            cert_path = os.path.join(tmpdirname, file_name)
            cert_paths[file_name] = cert_path
            content_decoded = b64decode(content).decode()

            with open(cert_path, "w") as f:
                f.write(content_decoded)

        hook_ssl_context = ssl.create_default_context(
            cafile=cert_paths["ca-bundle.pem"]
        )
        hook_ssl_context.load_cert_chain(
            certfile=cert_paths["cert.pem"], keyfile=cert_paths["key.pem"]
        )

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=hook_ssl_context
    ) as client:
        resp = await client.session.delete(url[:-9])
        assert resp.status == 200

        app_status = Application(metadata=stored.metadata,
                                 spec=stored.spec,
                                 status=stored.status)
        app_status.status.state = ApplicationState.WAITING_FOR_CLEANING
        resp = await client.session.put(url[:-8] + "status", json=app_status.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None
    assert stored.status.shutdown_grace_period is not None

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=hook_ssl_context
    ) as client:
        shutdown = ApplicationShutdown(token=token)
        resp = await client.session.put(url, json=shutdown.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.status.shutdown_grace_period is None


async def test_shutdown_hook_sending_tls_rbac(
    aiohttp_server, config, pki, db, loop, rbac_allow, client_ssl_context, hooks_config
):
    """Send a hook using ONLY the information present in the environment of the
    Deployment, with TLS enabled and RBAC set on the API.

    Conditions:
     * TLS:  enabled
     * RBAC: enabled
     * extras: send a request to the "shutdown" hook endpoint.

    Expectations:
        The information present on the DEPLOYED Kubernetes resources are enough to use
        the "shutdown" hook endpoint, and the request sent to this endpoint led to the
        deletion of the Application on the API.

    """
    config.authorization = "RBAC"
    config.authentication.strategy.static.enabled = False

    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []
    routes = web.RouteTableDef()

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    client_user = "client"
    controller_ssl_context = client_ssl_context(client_user)
    invalid_ssl_context = client_ssl_context("invalid_user")

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Deployment named `nginx-demo` already exists.
    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller created the `nginx-demo`
    # Deployment
    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = \
            app["spec"]["template"]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        status__shutdown_grace_period=utils.now(),
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=controller_ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=controller_ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)

        # As RBAC is set, the user defined in the Controller's certificate has to be
        # allowed to perform specific actions.
        async with rbac_allow(
            "kubernetes", "applications", "update", override_user=client_user
        ):
            async with rbac_allow(
                "kubernetes", "applications/status", "update", override_user=client_user
            ):
                async with rbac_allow(
                    "kubernetes", "clusters", "get", override_user=client_user
                ):
                    await controller.resource_received(app, start_observer=False)

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is None

    token, url = get_shutdown_hook_environment_value(stored)

    # Attempt to send a request to the hook endpoint with a valid certificate but a
    # non-allowed user. Should fail because of RBAC -> return a "403 Forbidden".
    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=invalid_ssl_context
    ) as client:
        shutdown = ApplicationShutdown(token=token)
        with pytest.raises(ClientResponseError, match="403"):
            await client.session.put(url, json=shutdown.serialize())

    # Attempt to send a request to the hook endpoint with a valid certificate, taken
    # from the Application itself. Should succeed.
    configmap = stored.status.last_observed_manifest[1]

    # Load the certificates into an SSL context.
    with tempfile.TemporaryDirectory() as tmpdirname:
        cert_paths = {}
        # Write the CA, the certificate and the key to files.
        for file_name, content in configmap["data"].items():
            cert_path = os.path.join(tmpdirname, file_name)
            cert_paths[file_name] = cert_path
            content_decoded = b64decode(content).decode()

            with open(cert_path, "w") as f:
                f.write(content_decoded)

        hook_ssl_context = ssl.create_default_context(
            cafile=cert_paths["ca-bundle.pem"]
        )
        hook_ssl_context.load_cert_chain(
            certfile=cert_paths["cert.pem"], keyfile=cert_paths["key.pem"]
        )

    async with Client(
        url=server_endpoint(api_server),
        loop=loop,
        ssl_context=controller_ssl_context
    ) as client:
        async with rbac_allow(
            "kubernetes", "applications", "delete", override_user=client_user
        ):
            resp = await client.session.delete(url[:-9])
        assert resp.status == 200

        async with rbac_allow(
            "kubernetes", "applications/status", "update", override_user=client_user
        ):
            app_status = Application(metadata=stored.metadata,
                                     spec=stored.spec,
                                     status=stored.status)
            app_status.status.state = ApplicationState.WAITING_FOR_CLEANING
            resp = await client.session.put(url[:-8] + "status", json=app_status.serialize())
            assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None
    assert stored.status.shutdown_grace_period is not None

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=hook_ssl_context
    ) as client:

        shutdown = ApplicationShutdown(token=token)

        # Allow the user defined in hooks-token.
        async with rbac_allow(
            "kubernetes",
            "applications/shutdown",
            "update",
            override_user="test-shutdown-hook-user",
        ):
            resp = await client.session.put(url, json=shutdown.serialize())
        assert resp.status == 200

    stored = await db.get(
        Application, namespace=app.metadata.namespace, name=app.metadata.name
    )
    assert stored.metadata.deleted is not None
    assert stored.status.shutdown_grace_period is None


async def test_shutdown_hook_reschedule(
    aiohttp_server, config, pki, db, loop, hooks_config
):
    """Attempt to reschedule an Application augmented with the "shutdown" hook. Enable
    TLS to use the "full-featured" hook (with the Secret containing a certificate).

    Conditions:
     * TLS:  enabled
     * RBAC: disabled
     * extras: give the Application a second time to the Kubernetes controller, to
       trigger it to handle the Application as if it was rescheduled. Have TLS enabled
       to generate a ConfigMap on the Application.

    Expectations:
        The rescheduling should occur without any interference of the resources
        generated by the "shutdown" hook and without any change applied to these
        resources.

    """
    routes = web.RouteTableDef()
    deploy_mangled_response = deepcopy(deployment_response)
    secret_mangled_response = deepcopy(secret_response)
    secret_mangled_responses = []

    server_cert = pki.gencert("api-server")
    config.tls = TlsServerConfiguration(
        enabled=True, client_ca=pki.ca.cert, cert=server_cert.cert, key=server_cert.key
    )

    client_cert = pki.gencert("client")
    client_tls = TlsClientConfiguration(
        enabled=True,
        client_ca=pki.ca.cert,
        client_cert=client_cert.cert,
        client_key=client_cert.key,
    )
    ssl_context = create_ssl_context(client_tls)

    # As part of the reconciliation loop started by ``controller.resource_received``,
    # the k8s controller checks if a Secret named `nginx-secret` already exists.
    @routes.get("/api/v1/namespaces/secondary/secrets/nginx-secret")
    async def _(request):
        return web.Response(status=404)

    # As part of the reconciliation loop, the k8s controller creates
    # the Kubernetes secret. Kubernetes secret stores Krake
    # authentication token and the Krake complete hook URL for the given application
    # and `ca.pem` secret
    @routes.post("/api/v1/namespaces/secondary/secrets")
    async def _(request):
        nonlocal secret_mangled_response
        nonlocal secret_mangled_responses

        resp = deepcopy(secret_mangled_response)
        rd = await request.read()
        secret = json.loads(rd)

        resp["metadata"]["name"] = secret["metadata"]["name"]
        resp["data"] = secret["data"]

        secret_mangled_responses.append(resp)
        return web.json_response(resp)

    @routes.get("/apis/apps/v1/namespaces/secondary/deployments/nginx-demo")
    async def _(request):
        return web.Response(status=404)

    @routes.post("/apis/apps/v1/namespaces/secondary/deployments")
    async def _(request):
        nonlocal deploy_mangled_response
        rd = await request.read()

        app = json.loads(rd)

        app_first_container = get_first_container(app)
        resp_first_container = get_first_container(deploy_mangled_response)
        resp_first_container["env"] = app_first_container["env"]
        resp_first_container["volumeMounts"] = app_first_container["volumeMounts"]

        deploy_mangled_response["spec"]["template"]["spec"]["volumes"] = \
            app["spec"]["template"]["spec"]["volumes"]

        return web.json_response(deploy_mangled_response)

    kubernetes_app = web.Application()
    kubernetes_app.add_routes(routes)
    kubernetes_server = await aiohttp_server(kubernetes_app)
    cluster = ClusterFactory(spec__kubeconfig=make_kubeconfig(kubernetes_server))

    # We only consider the first resource in the manifest file, that is a Deployment.
    # This Deployment should be modified by the "complete" hook with ENV vars.
    app = ApplicationFactory(
        status__state=ApplicationState.PENDING,
        status__scheduled_to=resource_ref(cluster),
        status__is_scheduled=False,
        spec__hooks=["shutdown"],
        spec__manifest=[deployment_manifest],
        spec__observer_schema=[custom_deployment_observer_schema],
    )
    await db.put(cluster)
    await db.put(app)

    server_app = create_app(config)
    api_server = Server(server_app)

    await api_server.start_server(ssl=server_app["ssl_context"])
    assert api_server.scheme == "https"

    async with Client(
        url=server_endpoint(api_server), loop=loop, ssl_context=ssl_context
    ) as client:
        controller = KubernetesApplicationController(
            server_endpoint(api_server),
            worker_count=0,
            ssl_context=ssl_context,
            hooks=hooks_config,
        )
        await controller.prepare(client)
        # Observer started here in order to be stopped afterwards,
        # otherwise get an exception from the Controller trying to stop a non-existing
        # Observer.
        await controller.resource_received(app, start_observer=True)

        stored = await db.get(
            Application, namespace=app.metadata.namespace, name=app.metadata.name
        )
        assert stored.status.state == ApplicationState.RUNNING
        assert stored.status.last_observed_manifest is not None

        # Do a rescheduling --> start the reconciliation loop
        await controller.resource_received(stored, start_observer=False)

        stored = await db.get(
            Application, namespace=app.metadata.namespace, name=app.metadata.name
        )
        assert stored.status.state == ApplicationState.RUNNING
        assert stored.status.last_observed_manifest is not None
